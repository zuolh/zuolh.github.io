{"meta":{"title":"zuolh","subtitle":"测试：左爷","description":"","author":"zuolh","url":"https://www.zuolh.com","root":"/"},"pages":[{"title":"about","date":"2021-04-14T06:06:10.000Z","updated":"2021-07-26T07:46:46.851Z","comments":true,"path":"about/index.html","permalink":"https://www.zuolh.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-04-14T06:04:47.000Z","updated":"2021-07-26T07:46:46.852Z","comments":true,"path":"categories/index.html","permalink":"https://www.zuolh.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-04-14T06:05:35.000Z","updated":"2021-07-26T07:46:46.855Z","comments":true,"path":"tags/index.html","permalink":"https://www.zuolh.com/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-04-14T06:06:32.000Z","updated":"2021-07-26T07:46:46.853Z","comments":true,"path":"friends/index.html","permalink":"https://www.zuolh.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Git常用命令","slug":"yuque/Git常用命令","date":"2021-07-23T10:22:32.000Z","updated":"2021-07-26T14:46:47.598Z","comments":true,"path":"2021/07/23/yuque/Git常用命令/","link":"","permalink":"https://www.zuolh.com/2021/07/23/yuque/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux常用命令","slug":"yuque/Linux常用命令","date":"2021-07-23T06:26:40.000Z","updated":"2021-07-26T14:46:47.618Z","comments":true,"path":"2021/07/23/yuque/Linux常用命令/","link":"","permalink":"https://www.zuolh.com/2021/07/23/yuque/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查看进程：ps -ef | grep XXX杀进程：kill -9 XXX​","categories":[],"tags":[]},{"title":"idea的Artifacts工具打包jmeter中无法调用的问题","slug":"yuque/idea的Artifacts工具打包jmeter中无法调用的问题","date":"2021-06-16T07:53:16.000Z","updated":"2021-07-26T14:46:47.638Z","comments":true,"path":"2021/06/16/yuque/idea的Artifacts工具打包jmeter中无法调用的问题/","link":"","permalink":"https://www.zuolh.com/2021/06/16/yuque/idea%E7%9A%84Artifacts%E5%B7%A5%E5%85%B7%E6%89%93%E5%8C%85jmeter%E4%B8%AD%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"jmeter 是用来做接口测试，但是接口调用需要进行 sign，所以需要对开发对加密的方法类进行打包放在 jmeter 中进行调用，但是出现了打包在 jmeter 中依旧报错的问题，后面发现是 idea 打包的 Artifacts 工具打出来的包在 jmeter 中识别不了，又通过 maven 插件帮助打包才可以使用，打包方式如下：在 maven 工程的 pom 文件的插件部分加入以下代码（注意：插入在 build 下，而非 pluginManagement 下）​ &lt;plugins> &lt;plugin> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>2.3.2&lt;/version> &lt;configuration> &lt;source>1.8&lt;/source> &lt;target>1.8&lt;/target> &lt;/configuration> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-assembly-plugin&lt;/artifactId> &lt;configuration> &lt;descriptorRefs> &lt;descriptorRef>jar-with-dependencies&lt;/descriptorRef> &lt;/descriptorRefs> &lt;archive> &lt;manifest> &lt;mainClass>com.hz.dx&lt;/mainClass>&lt;!--这里改成自己的主类位置--> &lt;/manifest> &lt;/archive> &lt;/configuration> &lt;executions> &lt;execution> &lt;id>make-assembly&lt;/id> &lt;phase>package&lt;/phase> &lt;goals> &lt;goal>single&lt;/goal> &lt;/goals> &lt;/execution> &lt;/executions> &lt;/plugin> &lt;/plugins> 用 maven 工具打包之后可以在左侧的 target 文件夹中看到胖瘦两包 将胖包 getDxSign-1.0-SNAPSHOT-jar-with-dependencies.jar 放到 jmeter 的\\apache-jmeter-5.1.1\\lib\\ext 目录下在 jmeter 中通过 beanshell 方式编写代码导入即可调用对应的方法​","categories":[],"tags":[]},{"title":"springboot集成swagger2错误解决java.lang.IllegalArgumentException: No enum constant org.springframework.web.bind.annotation...","slug":"yuque/springboot集成swagger2错误解决java.lang.IllegalArgumentException! No enum constant org.springframework.web","date":"2021-05-11T08:20:02.000Z","updated":"2021-07-26T14:46:47.661Z","comments":true,"path":"2021/05/11/yuque/springboot集成swagger2错误解决java.lang.IllegalArgumentException! No enum constant org.springframework.web/","link":"","permalink":"https://www.zuolh.com/2021/05/11/yuque/springboot%E9%9B%86%E6%88%90swagger2%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3java.lang.IllegalArgumentException!%20No%20enum%20constant%20org.springframework.web/","excerpt":"","text":"springboot 在集成 swagger2 启动时遇到如下错误： java.lang.IllegalArgumentException: No enum constant org.springframework.web.bind.annotation.RequestMethod.post at java.lang.Enum.valueOf(Enum.java:238) ~[na:1.8.0_261] at org.springframework.web.bind.annotation.RequestMethod.valueOf(RequestMethod.java:35) ~[spring-web-5.1.3.RELEASE.jar:5.1.3.RELEASE] at springfox.documentation.swagger.readers.operation.OperationHttpMethodReader.apply(OperationHttpMethodReader.java:49) ~[springfox-swagger-common-2.6.1.jar:2.6.1] at springfox.documentation.spring.web.plugins.DocumentationPluginsManager.operation(DocumentationPluginsManager.java:123) [springfox-spring-web-2.6.1.jar:2.6.1] at springfox.documentation.spring.web.readers.operation.ApiOperationReader.read(ApiOperationReader.java:73) [springfox-spring-web-2.6.1.jar:2.6.1] at springfox.documentation.spring.web.scanners.CachingOperationReader$1.load(CachingOperationReader.java:50) [springfox-spring-web-2.6.1.jar:2.6.1] at springfox.documentation.spring.web.scanners.CachingOperationReader$1.load(CachingOperationReader.java:48) [springfox-spring-web-2.6.1.jar:2.6.1] at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3527) [guava-18.0.jar:na] at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2319) [guava-18.0.jar:na] at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2282) [guava-18.0.jar:na] at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2197) [guava-18.0.jar:na] at com.google.common.cache.LocalCache.get(LocalCache.java:3937) [guava-18.0.jar:na] at com.google.common.cache.LocalCache.getOrLoad(LocalCache.java:3941) [guava-18.0.jar:na] at com.google.common.cache.LocalCache$LocalLoadingCache.get(LocalCache.java:4824) [guava-18.0.jar:na] at com.google.common.cache.LocalCache$LocalLoadingCache.getUnchecked(LocalCache.java:4830) [guava-18.0.jar:na] at springfox.documentation.spring.web.scanners.CachingOperationReader.read(CachingOperationReader.java:57) [springfox-spring-web-2.6.1.jar:2.6.1] at springfox.documentation.spring.web.scanners.ApiDescriptionReader.read(ApiDescriptionReader.java:66) [springfox-spring-web-2.6.1.jar:2.6.1] at springfox.documentation.spring.web.scanners.ApiListingScanner.scan(ApiListingScanner.java:89) [springfox-spring-web-2.6.1.jar:2.6.1] at springfox.documentation.spring.web.scanners.ApiDocumentationScanner.scan(ApiDocumentationScanner.java:70) [springfox-spring-web-2.6.1.jar:2.6.1] at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.scanDocumentation(DocumentationPluginsBootstrapper.java:85) [springfox-spring-web-2.6.1.jar:2.6.1] at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.start(DocumentationPluginsBootstrapper.java:127) [springfox-spring-web-2.6.1.jar:2.6.1] at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:182) [spring-context-5.1.3.RELEASE.jar:5.1.3.RELEASE] at org.springframework.context.support.DefaultLifecycleProcessor.access$200(DefaultLifecycleProcessor.java:53) [spring-context-5.1.3.RELEASE.jar:5.1.3.RELEASE] at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:360) [spring-context-5.1.3.RELEASE.jar:5.1.3.RELEASE] at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:158) [spring-context-5.1.3.RELEASE.jar:5.1.3.RELEASE] at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:122) [spring-context-5.1.3.RELEASE.jar:5.1.3.RELEASE] at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:879) [spring-context-5.1.3.RELEASE.jar:5.1.3.RELEASE] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh(ServletWebServerApplicationContext.java:163) [spring-boot-2.1.1.RELEASE.jar:2.1.1.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) [spring-context-5.1.3.RELEASE.jar:5.1.3.RELEASE] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) [spring-boot-2.1.1.RELEASE.jar:2.1.1.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.1.RELEASE.jar:2.1.1.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.1.RELEASE.jar:2.1.1.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.1.RELEASE.jar:2.1.1.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.1.RELEASE.jar:2.1.1.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.1.RELEASE.jar:2.1.1.RELEASE] at com.zuolh.lab.Application.main(Application.java:19) [classes&#x2F;:na] 在 controller 中用的是注解@RequestMapping,在集成 swagger2 之前可以正常访问， 那问题就一定处在 swagger2 相关的 code 中， 于是检查在 code 中哪里用到了 httpMethod, 发现了问题所在： public enum RequestMethod &#123; GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE; private RequestMethod() &#123; &#125; 枚举类中 method 方法都是大写， 而我的代码中将 httpmethod 写成了： @ApiOperation(value = \"登录成功后获取cookies信息\", httpMethod = \"post\") 所以只需要将 httpMethod=”post”改为 httpMethod = “POST”就好了","categories":[],"tags":[]},{"title":"返回cookies信息的post请求的开发","slug":"yuque/返回cookies信息的post请求的开发","date":"2021-05-10T05:30:02.000Z","updated":"2021-07-26T14:46:47.673Z","comments":true,"path":"2021/05/10/yuque/返回cookies信息的post请求的开发/","link":"","permalink":"https://www.zuolh.com/2021/05/10/yuque/%E8%BF%94%E5%9B%9Ecookies%E4%BF%A1%E6%81%AF%E7%9A%84post%E8%AF%B7%E6%B1%82%E7%9A%84%E5%BC%80%E5%8F%91/","excerpt":"","text":"在包 com.zuolh.lab 下创建一个 MyPostMethod 类，代码如下： package com.zuolh.lab; import com.alibaba.fastjson.JSONObject; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiOperation; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletResponse; /** * &lt;p/> * * @author zuolihong * @version 1.0 * @className MyPostMethod * @date 2021/5/8 17:22 */ @RestController //访问地址前要加/postApi @RequestMapping(\"/postApi\") public class MyPostMethod &#123; private static Cookie cookie; @RequestMapping(value = \"/login\", method = RequestMethod.POST) @ApiOperation(value = \"登录成功后获取cookies信息\", httpMethod = \"post\") @ApiImplicitParam(name = \"登录\", required = true, paramType = \"query\") public String login(HttpServletResponse response, @RequestParam(value = \"loginName\", required = true) String loginName, @RequestParam(value = \"password\", required = true) String password) &#123; if (loginName.equals(\"zuolh\") &amp;&amp; password.equals(\"111111\")) &#123; cookie = new Cookie(\"login\", \"success\"); response.addCookie(cookie); return \"恭喜登录成功\"; &#125; return \"用户名或者密码错误\"; &#125; &#125; 运行成功后通过 jmeter 进行调用：调用结果： 添加 Debug Sampler 查看 cookie 信息 jmeter 里添加 sampler→Debug Sampler，去 jmeter 所在的 bin 目录下的 jmeter.properties 文件，将“#CookieManager.save.cookies=false”修改成“CookieManager.save.cookies=true”保存，重启 jmeter，重新调用，查看 Debug Sampler","categories":[],"tags":[]},{"title":"SpringBoot + Swagger2-ui 自动生成API文档","slug":"yuque/SpringBoot + Swagger2-ui 自动生成API文档","date":"2021-05-08T06:35:33.000Z","updated":"2021-07-26T14:46:47.695Z","comments":true,"path":"2021/05/08/yuque/SpringBoot + Swagger2-ui 自动生成API文档/","link":"","permalink":"https://www.zuolh.com/2021/05/08/yuque/SpringBoot%20+%20Swagger2-ui%20%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90API%E6%96%87%E6%A1%A3/","excerpt":"","text":"什么是 SwaggerSwagger 是一个 Restful 风格接口的文档在线自动生成和测试的框架官网：http://swagger.io官方描述：The World’s Most Popular Framework for APIs. springboot 集成 swagger -ui1、pom.xml 中添加依赖&lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger-ui&lt;/artifactId> &lt;version>2.6.1&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger2&lt;/artifactId> &lt;version>2.6.1&lt;/version> &lt;/dependency> 2、在 Application 同级目录新建 SwaggerController 文件package com.zuolh.lab; import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; //swagger2的配置文件，在项目的启动类的同级文件建立 @Configuration @EnableSwagger2 //是否开启swagger，正式环境一般是需要关闭的（避免不必要的漏洞暴露！），可根据springboot的多环境配置进行设置 @ConditionalOnProperty(name = \"swagger.enable\", havingValue = \"true\") public class SwaggerController &#123; // swagger2的配置文件，这里可以配置swagger2的一些基本的内容，比如扫描的包等等 @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .pathMapping(\"/\") .select() // 为当前包路径 .apis(RequestHandlerSelectors.basePackage(\"com.zuolh.lab\")) .paths(PathSelectors.any()) .build(); &#125; // 构建 api文档的详细信息函数,注意这里的注解引用的是哪个 private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() // 页面标题 .title(\"zuolh的接口文档\") // 创建人信息 .contact(\"zuolh\") // 版本号 .version(\"1.0\") // 描述 .description(\"更多请关注：https://www.zuolh.com/\") .termsOfServiceUrl(\"https://www.zuolh.com/\") .version(\"1.0\") .build(); &#125; &#125; 3、在 controller 上添加注解，自动生成 APIpackage com.zuolh.lab; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiOperation; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.HashMap; import java.util.Objects; import java.util.Map; /** * &lt;p/> * * @author zuolihong * @version 1.0 * @className MyGetMethod * @date 2021/4/30 14:27 */ @RestController @RequestMapping(\"/zuo\") @Api(description = \"get请求\") public class MyGetMethod &#123; /** * 调用接口将cookie信息加到浏览器的cookie中去 * @param response * @return */ @ApiOperation(value=\"向浏览器添加cookies信息\") @GetMapping(\"/addCookies\") public String addCookies(HttpServletResponse response)&#123; Cookie cookie = new Cookie(\"login\",\"true1\"); response.addCookie(cookie); return \"返回cookies信息成功\"; &#125; /** * 要求客户端携带cookies访问 */ @RequestMapping(value = \"/get/with/cookies\",method = RequestMethod.GET) @ApiOperation(value=\"判断访问是否带入cookie信息\") public String getWithCookies(HttpServletRequest request)&#123; Cookie[] cookies = request.getCookies(); if(Objects.isNull(cookies))&#123; return \"必须携带cookies信息111\"; &#125; for(Cookie cookie:cookies)&#123; System.out.println(\"----------------\"+cookie.getName()+\" \"+cookie.getValue()); if (cookie.getName().equals(\"login1\") &amp;&amp; cookie.getValue().equals(\"false\"))&#123; return \"访问成功\"; &#125; &#125; return \"必须携带cookies信息2222\"; &#125; /** * 第一种：需要访问携带参数的get请求，参数格式是param=p1&amp;&amp;param1=p2 * */ @GetMapping(\"/get/with/param\") @ApiOperation(value=\"访问带有参数\") @ApiImplicitParam(paramType = \"query\",name = \"a\",dataType = \"String\",required = true,value = \"输入的服饰类型\",defaultValue = \"裤子\") public String getWithParam(@RequestParam String a)&#123; return putList(a); &#125; public String putList(String a)&#123; Map&lt;String, String> list = new HashMap&lt;>(); list.put(\"鞋子\",\"100\"); list.put(\"裤子\",\"500dddddddddd\"); return list.get(a); &#125; /** * 第二种：需要访问携带参数的get请求，参数格式是ip:port/get/cookies/param1/param2格式 */ @ApiOperation(\"访问带的参数格式与上一个方法不同\") @RequestMapping(value = \"/get/with/param/&#123;a&#125;\",method = RequestMethod.GET) public String getWithParam1(@PathVariable String a)&#123; Map&lt;String, String> list = new HashMap&lt;>(); list.put(\"鞋子\",\"100\"); list.put(\"裤子\",\"500\"); return list.get(a); &#125; &#125; 注解含义： @Api：用在请求的类上，表示对类的说明 tags&#x3D;&quot;说明该类的作用，可以在UI界面上看到的注解&quot; value&#x3D;&quot;该参数没什么意义，在UI界面上也看到，所以不需要配置&quot; @ApiOperation：用在请求的方法上，说明方法的用途、作用 value&#x3D;&quot;说明方法的用途、作用&quot; notes&#x3D;&quot;方法的备注说明&quot; @ApiImplicitParams：用在请求的方法上，表示一组参数说明 @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 name：参数名 value：参数的汉字说明、解释 required：参数是否必须传 paramType：参数放在哪个地方 · header --&gt; 请求参数的获取：@RequestHeader · query --&gt; 请求参数的获取：@RequestParam · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable · body（不常用） · form（不常用） dataType：参数类型，默认String，其它值dataType&#x3D;&quot;Integer&quot; defaultValue：参数的默认值 @ApiResponses：用在请求的方法上，表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如&quot;请求参数没填好&quot; response：抛出异常的类 @ApiModel：用于响应类上，表示一个返回响应数据的信息 （这种一般用在post创建的时候，使用@RequestBody这样的场景， 请求参数无法使用@ApiImplicitParam注解进行描述的时候） @ApiModelProperty：用在属性上，描述响应类的属性 4、启动后效果图：启动成功后访问：http://localhost:8889/swagger-ui.html","categories":[],"tags":[]},{"title":"软件测试工具大全（持续更新）","slug":"yuque/软件测试工具大全（持续更新）","date":"2021-04-13T15:40:07.000Z","updated":"2021-07-26T14:46:47.808Z","comments":true,"path":"2021/04/13/yuque/软件测试工具大全（持续更新）/","link":"","permalink":"https://www.zuolh.com/2021/04/13/yuque/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","excerpt":"","text":"软件测试工具大全，包括测试工具、框架和平台，偏向开源和免费。 说明表示开源软件；表示免费使用，或者个人免费 ；表示仅限 macOS 使用； 一. 大前端移动端抓包工具 Lyrebird - 移动端的抓包及 Mock 平台。（美团） 性能测试 PerfDog - 一款用于采集手机（Android&amp;iOS）性能数据的 PC 端工具。（腾讯） mobileperf - 基于 Python 实现的 Android 性能采集工具。（阿里） Pyroscope - 基于 Go 的开源实时性能分析平台。能帮你找出代码的性能问题、CPU 使用过高的原因，还有丰富的图表和调用树展示。 LoliProfiler** - **用于 Android 游戏和应用程序的C/C ++ 内存分析工具。（腾讯） 自动化跨平台 Appium - 用于 iOS、Android 和 Windows Apps 的自动化。 Detox - 端到端的移动应用测试和自动化框架。 Karate - UI/API 自动化测试框架。 Android SoloPi - 支持录制回放、一机多控和性能测试的 Android 自动化测试工具。（蚂蚁） scrcpy - 显示和控制你的 Android 设备。（Genymobile） minicap - 从 Android 设备中流式传输实时屏幕捕获数据。（STF） adb_shell - ADB 的 Python 实现，具有 Shell 和 FileSync 功能。 python-adb - Python ADB + Fastboot 实现。（Google） ADB Event Mirror - 通过命令行实现 Android 设备的一机多控。 ADB Enhanced - 增强 ADB 命令。 uiautomator2 - Android Uiautomator2 Python 包装器。（openatx） Moby - E2E 测试框架，用于具有复杂环境要求的测试。（Google） Docker-Android - Android in docker 解决方案，支持 noVNC 和视频录制。 iOS WebDriverAgent - iOS 的 WebDriver 服务实现，可用于远程控制 iOS 设备。 python-wda - Facebook WebDriverAgent Python 客户端库。（openatx） tidevice - iOS 自动化命令行工具。（阿里） libimobiledevice - 使用本机协议与 iOS 设备上的服务进行通信。 pymobiledevice - libimobiledevice 跨平台软件库的 python 实现。 idb - 用于自动化 iOS 模拟器和设备的命令行工具。 EarlGrey - iOS UI 自动化测试框架。（Google） KIF - 保持功能正常 - iOS 功能测试框架。 微信小程序 Minium - 微信小程序自动化框架, 提供了 Python 和 JavaScript 版本。（腾讯 测试平台 STF - 基于 Agular 和 Node.js 实现的移动设备管理平台 atxserver2 - 基于 Python 实现的移动设备管理平台。 DoraemonKit** - **一款功能齐全的客户端（ iOS 、Android、微信小程序、Flutter ）研发助手。（滴滴） Web 端 jsoup - Java HTML 解析器。 自动化 cypress - 对浏览器中运行的所有内容进行快速，轻松和可靠的测试。 qawolf - 将浏览器的测试速度提高了 10 倍。 TestCafe - 基于 Node.js 的端到端 Web 自动化测试工具。 gremlins.js - 用于 Web 应用程序和 Node.js 的 Monkey 测试库。 Helium - 用于 Web 自动化的最佳 Python 库。 Selenoid - 使用 Docker 容器启动浏览器的 Selenium hub 的强大实现。 Capybara - Web 应用程序的验收测试框架。 selenide - 使用 Java 进行简洁的 UI 测试。 splinter - 用于 Web 应用程序的 Python 测试框架。 gauge - 提供可靠的浏览器自动化测试框架。 PC 端跨平台 Spectron - 使用 ChromeDriver 和 WebdriverIO 轻松测试你的 Electron 应用程序 。 WindowsmacOS二. 服务端接口测试Mock vcrpy - 自动模拟 HTTP 交互。 Mockoon - 本地运行模拟 API 的最简单，最快的方法。 抓包 Fiddler - 跨平台的 Web 调试代理工具 mitmproxy - 交互式 HTTPS 代理，支持 PC 和 APP 抓包。 平台 Postman - API 开发协作平台。 YApi - 可本地部署的、打通前后端及测试的可视化的接口管理平台。 hoppscotch - 类似 Postman 的开源 API 开发协作平台。 浏量回放 GoReplay - 使用 go 开发的浏量回放工具。 vcr - 记录测试套件的 HTTP 交互，并在以后的测试运行期间重播它们，以进行快速，确定性和准确的测试。 框架 Dredd - 与语言无关的 HTTP API 测试工具。 HttpRunner* - *一个简单，优雅但功能强大的 HTTP（S）测试框架。 rest-assured - Java DSL，可轻松测试 REST 服务。 其他 HTTPie - 类似 cURL 但用起来更人性化也更强大的 HTTP 命令行工具。 数据库 DBeaver - 基于 Java 开发的通用数据库管理和开发工具。 sysbench - 基于 LuaJIT 的可编写脚本的多线程基准测试工具，常用于数据库基准测试。 性能测试 JMeter - k6 - 使用 Go 和 JavaScript 的现代负载测试工具。 ali - 生成 HTTP 负载并实时绘制结果。 Pumba - Docker 的混沌测试工具。 Vegeta - 多功能的 HTTP 负载测试工具。 三. 领域测试大数据人工智能四. 测试管理 AgileTC - 敏捷的测试用例管理平台，支持测试用例管理、执行计划管理、进度计算、多人实时协同等能力。（滴滴） 五. 测试框架MockJava Moco - 一个简单的 Mock 工具。 Mockito - 单元测试的 Mocking 框架。 覆盖率Java Super-Jacoco - 基于 Jacoco、Git 二次开发打造的一站式 JAVA 代码全量/diff 覆盖率收集平台。（滴滴） Python pytest 单元测试JavaScript Mocha - 用于 node.js 和浏览器的简单，灵活，有趣的 javascript 测试框架。 Jest - 令人愉快的 JavaScript 测试。 rewire - 轻松的进行 Node.js 单元测试。 fast-check - 使用 TypeScript 编写的 JavaScript 属性测试框架。 Android Robolectric - Android 单元测试框架。 Truth - Java 和 Android 的流畅断言，类似 AssertJ。 通用框架 robotframework - 用于验收测试和 RPA 的通用自动化框架。 taurus - 通过自动化友好的框架进行连续测试。 测试报告通用 Allure - 灵活的轻量级多语言测试报告工具。 iOSXCTestHTMLReport - 用于单元和 UI 测试的类似 Xcode 的 HTML 报告。","categories":[{"name":"测试工具","slug":"测试工具","permalink":"https://www.zuolh.com/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"测试工具","slug":"测试工具","permalink":"https://www.zuolh.com/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}]},{"title":"博客第1期","slug":"yuque/博客第1期","date":"2021-04-13T13:54:00.000Z","updated":"2021-07-26T14:46:47.848Z","comments":true,"path":"2021/04/13/yuque/博客第1期/","link":"","permalink":"https://www.zuolh.com/2021/04/13/yuque/%E5%8D%9A%E5%AE%A2%E7%AC%AC1%E6%9C%9F/","excerpt":"","text":"该博客模版案例来自 @蚂蚁金服体验技术部 插入带链接的标题（ctrl+K）Best Year in Music这幅可视化作品展示了 1960 年以来，Billboard 历年榜单的前五名音乐的变化情况，效果呈现设计感十足，还可以在聆听音乐的同时回顾音乐的变迁史。插入图片，点击图片，设置图片大小值得一提的是，作者正是大名鼎鼎的数据新闻站点 The Pudding。作为可视化新闻媒体中的姣姣者，The Pudding 擅长对那些兼具信息量和娱乐度的争议性话题进行可视化呈现，来使得复杂的观点变得更容易被公众理解。该团队虽然仅由数名全职记者和工程师组成，但战斗力强悍，目前已有数十个大型的数据可视化作品。输入作者 @诸岳(dengfuping) Road Suffixes in the USA美国道路命名多种多样，例如著名的纽约第五大道（Fifth Avenue），又或者凤凰城（Phoenix）的 Washington Street，Thomas Road，Union Hill Drive 等。不同的道路，有不同的叫法，Avenue, Street, Road, Drive 等等。想了解更多关于美国道路命名可以参考这篇文章。作者用 R 语言统计了美国每个县的每种道路后缀（例如 Avenue）的总里程，并把每个县总里程最大的道路后缀通过颜色映射到地图上。可以看出美国大部分县的道路都是以 Rd(Road 的缩写)结尾的。插入图片，点击图片，设置图片大小 另外还以柱状图的方式展示了每种道路后缀的总里程（英里）：by @长哲(changzhe) 「加餐」Hello World 图可视化图可视化是信息可视化的子领域，它通过展示元素、关系，帮助用户获取数据的洞悉能力。它已被广泛地应用在流程图、社交网络、英特网、蛋白质网络等关系数据的呈现。本文由 AntV 团队 @十吾(shiwu-5wap2) 👆 撰写，参考自[1][2]两篇图可视化学术论文，简要介绍图可视化的历史、背景、机遇与挑战。","categories":[],"tags":[]},{"title":"DONE","slug":"yuque/DONE","date":"2020-04-17T16:00:00.000Z","updated":"2021-07-26T14:46:47.813Z","comments":true,"path":"2020/04/18/yuque/DONE/","link":"","permalink":"https://www.zuolh.com/2020/04/18/yuque/DONE/","excerpt":"","text":"TEST 是不是同步发布","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.zuolh.com/categories/Hexo/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://www.zuolh.com/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.zuolh.com/tags/Hexo/"},{"name":"Yuque","slug":"Yuque","permalink":"https://www.zuolh.com/tags/Yuque/"}]}],"categories":[{"name":"测试工具","slug":"测试工具","permalink":"https://www.zuolh.com/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.zuolh.com/categories/Hexo/"}],"tags":[{"name":"测试工具","slug":"测试工具","permalink":"https://www.zuolh.com/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"name":"Github","slug":"Github","permalink":"https://www.zuolh.com/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.zuolh.com/tags/Hexo/"},{"name":"Yuque","slug":"Yuque","permalink":"https://www.zuolh.com/tags/Yuque/"}]}